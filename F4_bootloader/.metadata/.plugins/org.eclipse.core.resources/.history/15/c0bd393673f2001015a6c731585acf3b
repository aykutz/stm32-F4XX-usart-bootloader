/*
 * bootloader.c
 *
 *  Created on: Jan 14, 2026
 *      Author: huse2
 */

#include "bootloader.h"

extern char messageBuffer[BUFFER_SIZE];
extern uint8_t bufferIndex;
extern UART_HandleTypeDef huart2;

void processBootloaderCommand(void) {
	uint8_t command = messageBuffer[2];

	switch (command) {
	case GET_VERSION:
		handleGetVersion();
		break;
	case GET_HELP:
		handleGetHelp();
		break;
	case GET_ID:
		handleGetID();
		break;
	case READ_MEMORY:
		handleReadMemory();
		break;
	case GO_TO_ADDRESS:
		handleGoToAddress();
		break;
	default:
		break;
	}
	bufferIndex = 0;
	memset(messageBuffer, 0, BUFFER_SIZE);

}
void handleGetVersion(void) {
	uint8_t response[2] = { 0 };
	if (BOOTLOADER_VERSION > 0 && BOOTLOADER_VERSION <= 255) {
		response[0] = ACK;
		response[1] = BOOTLOADER_VERSION;
	} else {
		response[0] = NACK;
		response[1] = UNKNOWN;
	}
#ifdef PRINT_DEBUG
	printf("bootloader version -> 0x%x \r\n", BOOTLOADER_VERSION);
#endif
	HAL_UART_Transmit(UART_PORT, response, sizeof(response), HAL_MAX_DELAY);

}

void handleGetHelp(void) {
	uint8_t commands[] = {
	GET_HELP,					//					0x00
			GET_VERSION,				//					0x01
			GET_ID,						//			0x02
			READ_MEMORY,				//					0x11
			GO_TO_ADDRESS,				//				0x21
			WRITE_MEMORY,				//				0x31
			ERASE,						//						0x43
			WRITE_PROTECT_UNPROTECT,	//		0x63
			READOUT_PROTECT_UNPROTECT,	//	0x82
			GET_CHECKSUM,				//				0xA1
			};
	uint8_t totalCommands = sizeof(commands) / sizeof(commands[0]);

	uint8_t response[1 + 1 + 1 + sizeof(commands)] = { 0 };
	response[0] = ACK;
	response[1] = totalCommands;
	response[2] = BOOTLOADER_VERSION;
	memcpy(&response[3], commands, totalCommands);

	HAL_UART_Transmit(UART_PORT, response, sizeof(response), HAL_MAX_DELAY);

}

void handleGetID(void) {
	uint8_t response[4] = { 0 };
	uint32_t IDCode = DBGMCU->IDCODE;
	uint8_t PIDLSB = IDCode & 0xFF;

	response[0] = ACK;
	response[1] = 0x01;
	response[2] = 0x04;
	response[3] = PIDLSB;

	HAL_UART_Transmit(UART_PORT, response, sizeof(response), HAL_MAX_DELAY);
}

void handleReadMemory(void) {

	uint8_t response[1] = { 0 };
	uint8_t offset = 3;

	uint32_t address = (messageBuffer[offset] << 24)
			| (messageBuffer[offset + 1] << 16)
			| (messageBuffer[offset + 2] << 8) | (messageBuffer[offset + 3]);

	uint8_t addressCheckSum = messageBuffer[offset + 4];
	uint8_t calculatedCheckSum = (messageBuffer[offset])
			^ (messageBuffer[offset + 1]) ^ (messageBuffer[offset + 2])
			^ (messageBuffer[offset + 3]);
	if (addressCheckSum != calculatedCheckSum) {
		response[0] = NACK;
		HAL_UART_Transmit(UART_PORT, response, sizeof(response), HAL_MAX_DELAY);
		return;
	}

	uint8_t N = messageBuffer[offset + 5];
	uint8_t Ncomplement = messageBuffer[offset + 6];

	if ((uint8_t) (N ^ Ncomplement) != 0XFF) {
		response[0] = NACK;
		HAL_UART_Transmit(UART_PORT, response, sizeof(response), HAL_MAX_DELAY);
		return;
	}

	uint8_t addressIsInvalid = verifyAddress(address);

	if (!addressIsInvalid) {
		response[0] = NACK;
		HAL_UART_Transmit(UART_PORT, response, sizeof(response), HAL_MAX_DELAY);
		return;
	}

	response[0] = ACK;
	HAL_UART_Transmit(UART_PORT, response, sizeof(response), HAL_MAX_DELAY);

	uint8_t numberOfBytes = N;
	uint8_t buffer[256];
	memcpy(buffer, (uint8_t*) address, numberOfBytes);
	HAL_UART_Transmit(UART_PORT, buffer, numberOfBytes, HAL_MAX_DELAY);

}

void handleGoToAddress(void){
	uint8_t response[1] = {0};

}

uint8_t verifyAddress(uint32_t address) {
	if ((address >= FLASH_BASE && address <= FLASH_END)
			|| (address >= SRAM1_BASE && address <= SRAM1_END)) {
		return 1;
	}

	return 0;

}








